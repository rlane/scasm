#!/usr/bin/env ruby
require 'trollop'
require 'scasm/isa'
require 'scasm/statement'
require 'scasm/value'

include SCASM

opts = Trollop.options do
  banner <<-EOS
scasm-disassembler

Usage:
       scasm-disassembler [options] [file]

where [options] are:
EOS
end

mem = ARGF.read.unpack("v*")
addr = 0
basic_opcode_map = SCASM::BASIC_OPCODES.invert
register_map = SCASM::REGISTERS.invert

read_immediate = lambda do
  word = mem[addr]
  addr += 1
  word
end

decode_op = lambda do |opcode|
  basic_opcode_map[opcode] || ("opcode(%#x)" % opcode)
end

decode_value = lambda do |value|
  if value <= 0x07
    Register.new register_map[value]
  elsif value <= 0x0f
    RegisterMemory.new register_map[value-0x08]
  elsif value <= 0x17
    OffsetRegisterMemory.new register_map[value-0x10], read_immediate[]
  elsif value == 0x18
    Pop.new
  elsif value == 0x19
    Peek.new
  elsif value == 0x1a
    Push.new
  elsif value == 0x1b
    SP.new
  elsif value == 0x1c
    PC.new
  elsif value == 0x1d
    O.new
  elsif value == 0x1e
    ImmediateMemory.new read_immediate[]
  elsif value == 0x1f
    Immediate.new read_immediate[]
  elsif value < 0x3f
    Immediate.new(value-0x20)
  end
end

while addr < mem.size
  inst = mem[addr]
  addr += 1
  opcode = inst & 0xf
  code_a = (inst >> 4) & 0x3f
  code_b = (inst >> 10) & 0x3f
  opsym = decode_op[opcode]
  val_a = decode_value[code_a].to_s
  val_b = decode_value[code_b].to_s
  printf "%s %s, %s # pc=%#x\n", opsym, val_a, val_b, addr
end
