#!/usr/bin/env ruby
require 'trollop'
require 'scasm/isa'
require 'scasm/statement'
require 'scasm/value'

include SCASM

opts = Trollop.options do
  banner <<-EOS
scasm-disassembler

Usage:
       scasm-disassembler [options] [file]

where [options] are:
EOS
end

mem = ARGF.read.unpack("v*")
addr = 0
basic_opcode_map = SCASM::BASIC_OPCODES.invert
register_map = SCASM::REGISTERS.invert

next_word = lambda do
  word = mem[addr]
  addr += 1
  word
end

decode_op = lambda do |opcode|
  basic_opcode_map[opcode] || ("opcode(%#x)" % opcode)
end

decode_value = lambda do |value|
  if value <= 0x07
    Register.new register_map[value]
  elsif value <= 0x0f
    RegisterMemory.new register_map[value-0x08]
  elsif value <= 0x17
    OffsetRegisterMemory.new register_map[value-0x10], next_word[]
  elsif value == 0x18
    Pop.new
  elsif value == 0x19
    Peek.new
  elsif value == 0x1a
    Push.new
  elsif value == 0x1b
    SP.new
  elsif value == 0x1c
    PC.new
  elsif value == 0x1d
    O.new
  elsif value == 0x1e
    ImmediateMemory.new next_word[]
  elsif value == 0x1f
    Immediate.new next_word[]
  elsif value < 0x3f
    Immediate.new(value-0x20)
  end
end

stmts = []

while addr < mem.size
  word = next_word[]
  opcode = word & 0xf
  code_a = (word >> 4) & 0x3f
  code_b = (word >> 10) & 0x3f
  opsym = decode_op[opcode]
  a = decode_value[code_a]
  b = decode_value[code_b]
  stmts << Instruction.new(opsym, a, b)
end

stmts.each do |stmt|
  puts stmt
end
