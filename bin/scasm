#!/usr/bin/env ruby
require 'trollop'
require 'stringio'
require 'scasm/isa'

opts = Trollop.options do
  banner <<-EOS
scasm - the Ship Computer Assembler

This is an assembler for the DCPU-16 computer used in the game 0x10c.
CPU specs: http://0x10c.com/doc/dcpu-16.txt

Usage:
       scasm [options] [file]

where [options] are:
EOS

  opt :output, "Output filename", :short => 'o', :type => :string

  text <<-EOS

If no input file is given input is read from stdin. If no output file is given
the output will be written to filename.bin or stdout.
  EOS
end

module SCASM

class Slate < BasicObject
  def initialize
    @stmts = []
  end

  def eval code
    instance_eval code
  end

  def assemble
    io = ::StringIO.new
    @stmts.each { |stmt| stmt.assemble io }
    io.string
  end

  def inst opsym, a, b
    @stmts << Instruction.new(opsym, a, b)
  end

  def reg regsym
    Register.new regsym
  end

  def regmem regsym
    RegisterMemory.new regsym
  end

  def iregmem regsym, imm
    OffsetImmediateMemory.new regsym, imm
  end

  def pop
    Pop.new
  end

  def peek
    Peek.new
  end

  def push
    Push.new
  end

  def sp
    SP.new
  end

  def pc
    PC.new
  end

  def o
    O.new
  end

  def imem imm
    ImmediateMemory.new imm
  end

  def imm imm
    Immediate.new imm
  end

  # Add a method for each instruction
  BASIC_OPCODES.each do |opsym,opcode|
    define_method(opsym) { |*a| inst opsym, *a }
  end

  # Add a constant for each register
  REGISTERS.each do |regsym,regnum|
    const_set regsym, regsym
  end
end

class Statement
  def assemble io
    fail 'unimplemented'
  end
end

class Instruction < Statement
  def initialize opsym, a, b
    @opsym = opsym
    @a = a
    @b = b
  end

  def assemble io
    if opcode = BASIC_OPCODES[@opsym]
      code_a, imm_a = @a.assemble
      code_b, imm_b = @b.assemble
      code = opcode | (code_a<<4) | (code_b<<10)
      io.write [code, imm_a, imm_b].compact.pack('v*')
    elsif opcode = EXTENDED_OPCODES[@opsym]
      code_a, imm_a = @a.assemble
      fail unless @b == nil
      code = (opcode<<4) | (code_a<<10)
      io.write [code, imm_a].compact.pack('v*')
    else
      fail "unknown opsym #{@opsym.inspect}"
    end
  end
end

class Data < Statement
end

class Label < Statement
end

class Value
  def assemble
    fail "not implemented"
  end
end

class Register < Value
  def initialize regsym
    fail "invalid register #{regsym.inspect}" unless REGISTERS.member? regsym
    @regsym = regsym
  end

  def assemble
    return REGISTERS[@regsym]
  end
end

class RegisterMemory < Value
  def initialize regsym
    fail "invalid register #{regsym.inspect}" unless REGISTERS.member? regsym
    @regsym = regsym
  end

  def assemble
    return 0x08 + REGISTERS[@regsym]
  end
end

class OffsetImmediateMemory < Value
  def initialize regsym, imm
    fail "invalid register #{regsym.inspect}" unless REGISTERS.member? regsym
    @regsym = regsym
    @imm = imm
  end

  def assemble
    return (0x10 + REGISTERS[@regsym]), @imm
  end
end

class Pop < Value
  def assemble
    return 0x18
  end
end

class Peek < Value
  def assemble
    return 0x19
  end
end

class Push < Value
  def assemble
    return 0x1a
  end
end

class SP < Value
  def assemble
    return 0x1b
  end
end

class PC < Value
  def assemble
    return 0x1c
  end
end

class O < Value
  def assemble
    return 0x1d
  end
end

class ImmediateMemory < Value
  def initialize imm
    @imm = imm
  end

  def assemble
    return 0x1e, @imm
  end
end

class Immediate < Value
  def initialize imm
    @imm = imm
  end

  def assemble
    if @imm <= 0x1f
      return 0x20 + @imm
    else
      return 0x1f, @imm
    end
  end
end

end

if ARGV[0]
  input_io = File.open(ARGV[0])
else
  input_io = $stdin
end

if opts[:output]
  output_io = File.open(opts[:output], 'w')
elsif input_io != $stdin
  filename = File.join(File.dirname(input_io.path), File.basename(input_io.path, '.scasm') + '.bin')
  output_io = File.open(filename, 'w')
else
  output_io = $stdout
end

slate = SCASM::Slate.new
slate.eval input_io.read
output_io.write slate.assemble
